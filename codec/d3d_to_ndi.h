#ifndef D3D_TO_NDI_H
#define D3D_TO_NDI_H

#include "av_to_d3d.h"
#include <QList>
#include <d3dcompiler.h>

// merge sources from all av2d3d
struct D3D11_MAPPED_SUBRESOURCE;
struct ID3D11BlendState;

// This class is used by both client and server to generate local ndi source,
// which can be captured by OBS for use.
// It use d3d11 to alpha blend all sources textures to one target texture
// Then copy the staging texture to NDI stream. The merge process is called
// by ndi sender thread to use the fps timing generated by NDI.
class DxToNdi : public IDebugCollectable {
    QList<IDxSrc*> sources;

    ComPtr<ID3D11DeviceContext> _d3d11_deviceCtx = nullptr;
    ComPtr<ID3D11BlendState> _d3d11_blendState = nullptr;
    ComPtr<ID3D11Device> _d3d11_device = nullptr;
    ComPtr<ID3D11SamplerState> _d3d11_samplerState = nullptr;
    ComPtr<ID3D11VertexShader> _d3d11_vertexShader = nullptr;
    ComPtr<ID3D11InputLayout> _d3d11_inputLayout = nullptr;
    ComPtr<ID3D11PixelShader> _d3d11_pixelShader = nullptr;
    ComPtr<ID3D11Buffer> _d3d11_vertexBuffer = nullptr;

    ComPtr<ID3D11ShaderResourceView> _textureView = nullptr;
    ComPtr<ID3D11RenderTargetView> _renderTargetView = nullptr;
    ComPtr<ID3D11Texture2D> _texture_rgba_src = nullptr;
    ComPtr<ID3D11Texture2D> _texture_rgba_target = nullptr;
    ComPtr<ID3D11Texture2D> _texture_rgba_copy = nullptr;

    ComPtr<ID3DBlob> _vertex_shader = nullptr;
    ComPtr<ID3DBlob> _pixel_shader = nullptr;

    HANDLE _texture_rgba_target_handle;

    uint32_t _width{ 0 };
    uint32_t _height{ 0 };

    std::atomic_bool _inited = false;
    bool _mapped = false;

    FpsCounter fps;

public:
    DxToNdi();
    ~DxToNdi();

    QString debugInfo();

    void registerSource(IDxSrc* src);
    void unregisterSource(IDxSrc* src);

    bool init();
    bool compileShader();
    void resetDeviceContext(int width, int height);
    bool createSharedSurf(int width, int height);
    void releaseSharedSurf();

    // Will be called from ndi thread,
    // to ensure sources no change during render we need to lock
    QMutex lock;
    bool mapNdi(NDIlib_video_frame_v2_t* frame);
    void unmapNdi();

    // cooperate with ndi to av, as we can copy from texture, not from cpu
    bool copyTo(ID3D11Device* dev, ID3D11DeviceContext* ctx, ID3D11Texture2D *dest);
};

#endif // D3D_TO_NDI_H
